rem Back to the minefield
//
//  Written in Vimclair BASIC for ZX Spectrum 128.
//
rem By Marcos Cruz (programandala.net), 2016, 2017, 2018, 2019.
//
//  Based on "Campo de minas" (published by Indescomp), the Spanish
//  version of "Minefield", written by Ian Andrew.

// ==============================================================

border 0: paper 0: ink 0: flash 0: inverse 0: bright 0:\
clear 65535-21*8*3-8:\

let version$="0.62.0+201903110130":\
// Note: version number after Semantic Versioning: http://semver.org

goto @init

// ==============================================================
// Functions

deffn random_row()=int(rnd*mined_rows)+top_mined_row

deffn random_col()=int(rnd*30)+1

deffn txt$(n)=text$(lang,n,1 to text_len(lang,n))

// ==============================================================
// Start a new game

@new_game:

let level=first_level:\
let score=0

// ==============================================================
// Enter a new level

@new_level:

randomize udg1:\
gosub @select_udg_set

let surrounding_mines=0:\
let door_closed=0

// coordinates
let row=bottom_fence_row:\
let col=start_col:\
let old_row=row:\
let old_col=col

// list of coordinates, stored as chars
let trail$=chr$ row+chr$ col

// counter
let time=0

let protagonist_frame=0:\

let walking_mine_step=-1:\
let walking_mine_row=row:\
let walking_mine_col=col:\
let pa=7:\
let ss=0

let paper_color=7-level:\
let border_color=0:\
let mines=32+level*4

border border_color:\
paper paper_color:\
ink ink_color:\
cls:\
gosub @no_message:\
load!"fence.scr"code

let message$=fn txt$(putting_mines_txt):\
gosub @message

print paper 8;bright 1;\
  at top_fence_row+1,1;fn txt$(safe_zone_txt);\
  at bottom_fence_row-1,1;fn txt$(safe_zone_txt)

for w=1 to mines:\
  print \
    at fn random_row(),fn random_col();\
    ink paper_color;mine_udg$:\
  beep .0015,35:\
next w

print paper 8;\
  at top_fence_row+1,1;blank_field_row$;\
  at bottom_fence_row-1,1;blank_field_row$

gosub @no_message:\
gosub @new_status_bar

if level=first_level then \
  goto @l480
if level=last_level then \
  gosub @last_level: goto @l480

// XXX REMARK -- levels second..last_but_one:
// XXX TODO -- move to a subroutine
// XXX TODO -- store the position of the flowers, in order
// to restore them before the replay
let flowers=int(rnd*level)+1:\
for i=1 to flowers:\
  print at fn random_row(),fn random_col();flower_udg$:\
next i

@l480:

if level=(last_level-1) then \
  gosub @close_the_door

beep .0875,10

for n=1 to 20
  beep .002,n+20
next n
# print at 21,4;"         ": beep .05,37
goto @l535

@l500:

let old_row=row: let old_col=col

@l520:

let i$=inkey$
let row=row+(i$=cursor_keys$(4))-(i$=cursor_keys$(3))
let row=row-(row=(bottom_fence_row+1))
let col=col+(i$=cursor_keys$(2))-(i$=cursor_keys$(1))

// XXX TODO -- remove
let time=time+1

// XXX TODO -- improve or remove
# if level>=4 then \
#   if time>(260*paper_color+70) then \
#     if int(time/(3*paper_color+1))=(time/(3*paper_color+1)) then \
#       gosub @walking_mine

if old_row=row and old_col=col then \
  goto @l520

beep .003,-4

@l535:

print at old_row,old_col; paper pa;" "
let trail$=trail$+chr$ row+chr$ col

// XXX TODO -- move down to save the print
if door_closed then \
    if row=key_row then \
      if col=key_col then \
        print at row,col; paper pa;protagonist$(protagonist_frame+1):\
        let protagonist_frame=not protagonist_frame:\
        gosub @open_the_door:\
        goto @step_done

// make the first UDG bank the current font, in order to detect
// the graphics with `screen$()`:
poke 23606,udg1_font_low:poke 23607,udg1_font_high:\

// XXX REMAK -- There's a bug in Sinclar BASIC: the following
// calculations return a wrong non-integer value. That's why every
// value is calculated apart.

# let surrounding_mines=int(\
#   (screen$(row-1,col)<>" ")+\
#   (screen$(row+1,col)<>" ")+\
#   (screen$(row,col-1)<>" ")+\
#   (screen$(row,col+1)<>" "))

# let surrounding_mines=(screen$(row-1,col)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row+1,col)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row,col-1)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row,col+1)<>" ")

let found_char=code screen$(row,col):\
let front_surrounding_mines=screen$(row-1,col)=mine_char$:\
let back_surrounding_mines=screen$(row+1,col)=mine_char$:\
let left_surrounding_mines=screen$(row,col-1)=mine_char$:\
let right_surrounding_mines=screen$(row,col+1)=mine_char$:\

// restore the default font:
poke 23606,0:poke 23607,60

// mine?
if found_char=mine_char then \
  goto @explosion

// fence?
if found_char=fence_char then \
  goto @explosion

// flower?
if found_char=flower_char then \
  gosub @pick_flower

// bill?
if found_char=bill_char then \
  gosub @rescue

print at row,col; paper pa;protagonist$(protagonist_frame+1):\
let protagonist_frame=not protagonist_frame

@step_done:

let surrounding_mines=\
  front_surrounding_mines+\
  back_surrounding_mines+\
  left_surrounding_mines+\
  right_surrounding_mines:\
gosub @print_surrounding_mines:\
beep .04*sgn surrounding_mines,surrounding_mines*10

if row=top_fence_row then \
  goto @level_passed

goto @l500

// ==============================================================
// subroutine: close the door

@close_the_door:

let key_row=fn random_row():\
let key_col=fn random_col():\
print at key_row,key_col;key_udg$:\

let message$=fn txt$(you_need_key_txt):\
gosub @message

for i=60 to 10 step -5:\
  print at top_fence_row,door_col;"   ":\
  beep .125,i:\
  print at top_fence_row,door_col;fence$(1 to 3):\
  for j=1 to 7: next j:\
next i:\
gosub @no_message:\
let door_closed=1:\
return

// ==============================================================
// subroutine: open the door

@open_the_door:

let message$=fn txt$(open_door_txt):\
gosub @message:\
for i=10 to 60 step 5:\
  print at top_fence_row,door_col;fence$(1 to 3):\
  beep .125,i:\
  print at top_fence_row,door_col;"   ":\
  for j=1 to 7: next j:\
next i:\
gosub @no_message:\
let door_closed=0:\
return
 
// ==============================================================
// subroutine: status bar

@new_status_bar:

input ;:\
randomize udg_chars:\
gosub @select_udg_set:\
print #1;paper 8;ink 9;\
  at 0, 0;fn txt$(level_txt);\
  at 0, 6;fn txt$(near_mines_txt);\
  at 0,20;fn txt$(points_txt);inverse 1;\
  at 1,20;" 0000 ";inverse 0;\
  at 0,27;fn txt$(record_txt);inverse 1;\
  at 1,27;" 0000":\
randomize udg1:\
gosub @select_udg_set

@update_status_bar:

print #1;ink 9;paper 8;inverse 1; \
  at 1,0;"  ";level;"  ";\
  at 1,24-(score>9)-(score>99)-(score>999);score;\
  at 1,31-(record>9)-(record>99)-(record>999);record

@print_surrounding_mines:

print #1; ink 9; paper detector_color(surrounding_mines+1);\
  at 1,6;"      ";surrounding_mines;"      ":\
return

// ==============================================================
// subroutine: walking mine

// XXX TODO -- improve or remove

@walking_mine:

// XXX TODO -- try, after the latest changes (2016-06-12)

print at walking_mine_row,walking_mine_col; paper pa;" "

let walking_mine_step=walking_mine_step+2:\
beep .0018,60
let walking_mine_row=code trail$(walking_mine_step):\
let walking_mine_col=code trail$(walking_mine_step+1):\
if screen$(walking_mine_row,walking_mine_col)<>" " then \
  goto @explosion

// XXX TODO -- improve:
print at walking_mine_row,walking_mine_col; paper pa;"\h":\
return

// ==============================================================
// subroutine: pick flower

@pick_flower:

// XXX TODO --
let score=score+10
gosub @update_status_bar
return

// ==============================================================
// explosion

@explosion:

// XXX TODO -- remove mine count from the status bar

for i=20 to 1 step -1:\
  beep .003,i: print at row,col;"\c":\
  beep .002,10: print at row,col;dead_protagonist_udg$:\
next i
beep 1.6,-35
print at row,col;mine_udg$:\
gosub @replay:\

// XXX FIXME -- only if the replay was completed:
print at row,col;dead_protagonist_udg$

beep 1,-35
if score>record then \
  gosub @new_record
gosub @update_status_bar

// ==============================================================
// Again?

let message$=fn txt$(again_txt):\
gosub @message

@again:

pause 0:let i$=inkey$

if code(i$)>code("Z") then \
  let i$=chr$(code(i$)-32)

if i$=no$(lang) then goto @menu
if i$=yes$(lang) then goto @new_game

goto @again

// ==============================================================
// subroutine: message

@message:

gosub @no_message:\
randomize udg_chars:\
gosub @select_udg_set:\
print bright 1; ink 9; paper border_color;\
  at message_row,(32-len message$)/2;message$;:\
randomize udg1:\
gosub @select_udg_set:\
return

@no_message:

print at message_row,0;paper border_color;blank_row$;:\
return

// ==============================================================
// Rescue

@rescue:

gosub @the_nest
let dx=30
for u=.155 to .005 step -.01
  print at 0,dx; ink 0; paper 7;"\n "
  let dx=dx-1
  beep u,8: beep u,12: beep u,16
  border rnd*7
next u
for n=1 to 16
  print at 0,dx; ink 0; paper 7;"\n "
  let dx=dx-1+(dx=0)
  beep u+.005,8
  border rnd*7
  beep u+.005,12: beep u,16
next n
print at 0,0; paper 7;" "
for t=0 to 2
  for l=0 to 7 step 7
    ink l
    // XXX TODO -- simpler
    for n=1 to 5:\
      print at row+n,col+n;"*":\
      print at row-n,col+n;"*":\
      print at row+n,col-n;"*":\
      print at row-n,col-n;"*":\
    next n
    for n=1 to 5:\
      print at row,col+n;">":\
      print at row,col-n;"<":\
      print at row+n,col;"#":\
      print at row-n,col;"#":\
    next n
  next l
next t
ink 0
gosub @the_nest

print at 0,0; ink 7; paper 0;\
text$(lang,two_thousand_txt);

let score=score+2000
for b=0 to 7
  paper b: ink 9
  print at row,col;protagonist$(protagonist_frame+1):\
  let protagonist_frame=not protagonist_frame
  for n=1 to 14
    beep .002,50-n+b
    border 1: border 2: border 3: border 4
    border 5: border 6: border 7: border b
  next n
next b
border 0: paper 0: cls
for n=0 to 30 step 6
  for m=1 to 10
    beep .008,n+m
  next m
next n

if lang=spanish then

#  <------------------------------>
print at 3,8;\
  "¡Felicidades!"
#  <------------------------------>
print '\
  "Has rescatado a Bill. El mundo"'\
  "te está agradecido."
#  <------------------------------>
print ''''';\
  "Puntuación: ";score;"."
#  <------------------------------>
print \
  "¿Por qué no vuelves a jugar y"'\
  "tratas de mejorarla?"
#  <------------------------------>

elseif lang=english then

#  <------------------------------>
print at 3,6;\
  "Congratulations!"
#  <------------------------------>
print '\
  "Yo have rescue Bill. The world"'\
  "thanks you."
#  <------------------------------>
print ''''';\
  "Score: ";score;"."
#  <------------------------------>
print \
  "Why don't you play again and"'\
  "try to do it even better?"
#  <------------------------------>

elseif lang=interlingue then

// XXX TODO --

#  <------------------------------>
print at 3,6;\
  "Congratulations!"
#  <------------------------------>
print '\
  "Yo have rescue Bill. The world"'\
  "thanks you."
#  <------------------------------>
print ''''';\
  "Score: ";score;"."
#  <------------------------------>
print \
  "Why don't you play again and"'\
  "try to do it even better?"
#  <------------------------------>

else // Esperanto

#  <------------------------------>
print at 3,6;\
  "Gratulon!"
#  <------------------------------>
print '\
  "Vi savis Bill. La mondo dankas"'\
  "vin."
#  <------------------------------>
print ''''';\
  "Poentoj: ";score;"."
#  <------------------------------>
print \
  "Kial ne ludi plian fojon kaj"'\
  "klopodi fari eĉ pli bone?"
#  <------------------------------>

endif

if score>record then \
  gosub @new_record

goto @again

// ==============================================================
// subroutine: replay

@replay:

// XXX FIXME -- remove the surrounding mines
// XXX FIXME -- when the replay is ended, the explosion is show in the
// current position!

// XXX TODO -- 
# print at walking_mine_row,walking_mine_col;" ";\
#       at row,col;" "

for i=1 to 21:\
  print at i,0; over 1;paper paper_color;ink 9;blank_row$:\
next i
randomize udg_chars:\
gosub @select_udg_set

let paused_replay=0:\
gosub @show_replay_bar
randomize udg1:\
gosub @select_udg_set
for n=1 to 100: next n

let row=code trail$(1):\
let col=code trail$(2)

for t=1 to len trail$ step 2

@replay_control:

  // XXX REMARK -- At the moment the control keys must be the same in
  // all languages (P to pause and F to finish).

  let i$=inkey$
  if paused_replay then
    let paused_replay=(i$=""):\
    beep .1*not paused_replay,0:\
    if paused_replay then \
      goto @replay_control
    gosub @show_replay_bar
  endif
  if i$="f" or i$="F" then \
    goto @replay_end
  if i$="p" or i$="P" then \
    let paused_replay=1:\
    beep .1,10:\
    gosub @show_replay_bar

  print at row,col; paper 7;" "
  let row=code trail$(t):\
  let col=code trail$(t+1):\
  print at row,col; paper 7;protagonist$(protagonist_frame+1):\
  let protagonist_frame=not protagonist_frame
  beep .005,5+(t*40/(len trail$))

next t

@replay_end:

gosub @no_message:\
return

@show_replay_bar:

let message$=fn txt$(replay_controls_1_txt+paused_replay):\
  gosub @message:\
return

// ==============================================================
// subroutine: level passed

@level_passed:

let surrounding_mines=0:\
gosub @print_surrounding_mines

// XXX TODO -- improve time score with the frames system variable

let time_score=(int((2000-time)/50))*5
let time_score=time_score*(time_score>=50)+50*(time_score<50)
let time_score=time_score*level

// XXX TODO --
# restore @applause_sound:\
# gosub @sound

for i=1 to 8:\
  print at row,col;protagonist$(1):\
  if inkey$<>"" then goto @level_replay
#  for j=1 to 100:next j
  beep .1,0:\
  print at row,col;protagonist$(2):\
  beep .1,10:\
  if inkey$<>"" then goto @level_replay
next i

@level_replay:

// XXX TODO --
# restore @no_sound:\
# gosub @sound

print at row,col;paper pa;" "

gosub @replay

for i=4 to 22 step 6:\
  beep .005,i+24:\
next i

for i=1 to 8:\
  for j=1 to 6:\
    print at message_row,0;paper j;blank_row$;:\
    border j:\
  next j:\
next i:\
print at message_row,0;paper 0;blank_row$;:\
border border_color

// XXX TODO -- variable to flash the score
let score=score+time_score+mines:\
gosub @update_status_bar

let level=level+1:\
goto @new_level

// ==============================================================
// subroutine: new record

@new_record:

// XXX TMP --
let record=score:return

// XXX TODO -- rewrite:

for n=1 to 50
  border 1: border 2: border 3: border 4
next n
for n=1 to 50
  border 6: border 2: beep .002,40+(n/10): border 6
next n
randomize udg_chars:\
gosub @select_udg_set
for m=1 to 4
  for n=7 to 0 step -1
    print at 10,7; ink n;fn txt$(new_record_txt)
    beep .004,50-n
  next n
next m
print at 10,7; ink 9;fn txt$(new_record_txt)
randomize udg1:\
gosub @select_udg_set

// XXX TODO -- adapt

print at 21,0;\
  flash 1; paper 1; ink 7;\
  fn txt$(enter_initials_txt); flash 0;"         "

let record_player$="   "
for n=1 to 3
  @l5088:
  let record_player$(n)=inkey$
  if record_player$(n)=" " then \
    goto @l5088
  if record_player$(n)>="a" and record_player$(n)<="z" then \
    let record_player$(n)=chr$((code record_player$(n))-32)
  print at 21,24+n; ink 7; paper 1;record_player$(n)
  beep .12,(n*5)+20
  for m=1 to 4: next m
next n
let record=score
for n=1 to 12
  beep .0045,-10: border 1: border 2: border 6: border 4
next n
border border_color
beep .1,8
for n=1 to 4: next n
beep .1,8: beep .1,8: beep .1,20: beep .1,24: beep .1,18: beep .15,29
for n=1 to 7: next n
beep .12,22
for n=1 to 3: next n
beep .07,19: beep .08,17
for n=1 to 3: next n
beep .1,14: beep .1,12
print at 10,7;"                  "
return

// ==============================================================
// init

@init:

// Graphics

// There are three UDG banks:
//
// udg1: graphics 
// udg2: the Spanish and Interlingue characters
// udg3: the Esperanto characters

let udg1=65535-21*8*3:\
let udg2=udg1+21*8:\
let udg3=udg2+21*8:\
let udg_chars=udg2:\
load "UDG.BIN" code udg1-8
let udg1_font=udg1-256-8:\
let udg1_font_high=int(udg1_font/256):\
let udg1_font_low=udg1_font-(udg1_font_high*256)

// Constants

let first_level=6:rem XXX TMP -- change for debugging -- default=1
let last_level=7

let message_row=0:\
let top_fence_row=1:\
let bottom_fence_row=21:\
let top_safe_row=top_fence_row+1:\
let top_mined_row=top_safe_row+1:\
let bottom_safe_row=bottom_fence_row-1:\
let mined_rows=bottom_safe_row-top_safe_row-1:\
let door_col=14:\
let start_col=15

let blank_row$="                                "

dim protagonist$(2):\
let protagonist$="\d\e":\
let dead_protagonist_udg$="\l":\

let bill_char=46:\
let bill_udg$="\n":\
let fence_char=38:\
let fence_udg$="\f":\
let flower_char=49:\
let flower_udg$="\q":\
let key_char=48:\ // XXX TODO -- Not used.
let key_udg$="\p":\
let mine_char$="/":\
let mine_char=47:\
let mine_udg$="\o"

let fence$="\f\f\f\f\f\f\f\f\f\f\f\f\f\f   \f\f\f\f\f\f\f\f\f\f\f\f\f\f\f"

let blank_field_row$="                              "

let ink_color=9

let cursor_keys$=chr$ 8+chr$ 9+chr$ 11+chr$ 10:rem cursor keys

dim detector_color(4):\
let detector_color(1)=4:\
let detector_color(2)=5:\
let detector_color(3)=6:\
let detector_color(4)=2

// Variables

let record_player$="IAN":\
let record=250

// Languages

let english=1:\
let esperanto=2:\
let interlingue=3:\
let spanish=4:\

let langs=4

// Multilingual text

dim text$(langs,texts,32):\
dim text_len(langs,texts):\
dim yes$(langs):\
dim no$(langs)

gosub @texts:\
let lang=english

// Files

randomize udg1:\
gosub @select_udg_set:\
print at top_fence_row,0;fence$:\
for n=top_safe_row to bottom_safe_row:\
  border 7:\
  print at n,0;\
    fence_udg$+"                              "+fence_udg$:\
  border 0:\
next n:\
print at bottom_fence_row,0;fence$:\
save!"fence.scr"code 16384,6144

// ==============================================================
// XXX TMP -- tests

# let time=100
# let level=2
# goto @level_passed

# rem --------------------------------
# paper 2
# ink 7
# print at 15,15;mine_udg$;" (mine)=";
# gosub @graphics_font
# let tmp= code screen$(15,15)
# gosub @default_font
# print tmp

# print at 16,15;"  (space)=";
# gosub @graphics_font
# let tmp= code screen$(16,15)
# gosub @default_font
# print tmp

# stop

// ==============================================================
// menu

// XXX TODO -- complete

@menu:

border 1: paper 1: ink 7
cls

@update_menu:

print at 0,0;text$(lang,title_txt)

randomize udg_chars:\
gosub @select_udg_set

#  <------------------------------>
print '\
  "________________________________"''\
  inverse 1;text$(lang,instructions_txt,1);\
  inverse 0;text$(lang,instructions_txt,2 to)''\
  inverse 1;text$(lang,start_txt,1);\
  inverse 0;text$(lang,start_txt,2 to)''\
  inverse 1;text$(lang,credits_txt,1);\
  inverse 0;text$(lang,credits_txt,2 to)''\
  inverse 1;text$(lang,change_language_txt,1);\
  inverse 0;text$(lang,change_language_txt,2 to)''\
  "________________________________"
#  <------------------------------>

@menu_key

pause 0:let i$=inkey$
if code(i$)>code("Z") then \
  let i$=chr$(code(i$)-32)

if i$=text$(lang,instructions_txt,1) then \
  gosub @instructions:\
  goto @menu

if i$=text$(lang,start_txt,1) then \
  goto @new_game

if i$=text$(lang,credits_txt,1) then \
  gosub @credits:\
  goto @menu

if i$=text$(lang,change_language_txt,1) then
  let lang=lang+1
  if lang>langs then \
    let lang=1
  if lang=esperanto then
    let udg_chars=udg3
  else
    let udg_chars=udg2
  endif
  randomize udg_chars:\
  gosub @select_udg_set
  goto @update_menu
endif

beep .1 ,23:\
goto @menu_key

// ==============================================================
// subroutine: credits

@credits:

cls
randomize udg_chars:\
gosub @select_udg_set
print text$(lang,title_txt)''

if lang=spanish then

#      <------------------------------>
print "Versión ";version$
print
print "Autor:"
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Jugador de pruebas:"
print "  Irene Albert."
print
print "Un homenaje a y una reinterpre-"
print "tación de:"
print "  Minefield (Ian Andrew, 198x),"
print "  publicado en español por"
print "  Indescomp como Campo de minas."
print
print "Escrito en Vimclair BASIC para"
print "ZX Spectrum 128. Basado en parte"
print "en código y gráficos de Ian"
print "Andrew."
#      <------------------------------>

elseif lang=english then

#      <------------------------------>
print "Version ";version$
print
print "Author:"
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Test player:"
print "  Irene Albert."
print
print "A tribute to and a remake of:"
print "  Minefield (Ian Andrew, 198x),"
print "  published in Spanisha by"
print "  Indescomp as 'Campo de minas'."
print
print "Written in Vimclair BASIC for"
print "ZX Spectrum 128. Partly based on"
print "code and graphics by Ian Andrew."
#      <------------------------------>

elseif lang=interlingue then

#      <------------------------------>
print "Version ";version$
print
print "Autor:"
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Lusor de provas:"
print "  Irene Albert."
print
print "Un tribute a, e un"
print "reinterpretation de:"
print "  Minefield (Ian Andrew, 198x),"
print "  publicat in hispan de"
print "  Indescomp quam 'Campo de"
print "  minas'."
print
print "Scrit in Vimclair BASIC por ZX"
print "Spectrum 128. Partimen basat sur";
print "code e images de Ian Andrew."
#      <------------------------------>

elseif lang=esperanto then

#      <------------------------------>
print "Versio ";version$
print
print "Aŭtoro:"
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Provludanto:"
print "  Irene Albert."
print
print "Omaĝo kaj reinterpreto je:"
print "  Minefield (Ian Andrew, 198x),"
print "  publikigita en la hispana de"
print "  Indescomp kiel 'Campo de"
print "  minas'."
print
print "Verkita en Vimclair BASIC por ZX"
print "Spectrum 128. Parte bazita sur";
print "kodo kaj bildoj de Ian Andrew."
#      <------------------------------>

endif

randomize udg1:\
gosub @select_udg_set
pause 0
return

// ==============================================================
// subroutine: instructions

@instructions:

cls:\
print text$(lang,title_txt)

let i$=protagonist$(1):gosub @icon

if lang=spanish then

#      <------------------------------>
print  " Tú, la heroica damisela. Atra-";
#      <------------------------------>
print "  viesa los campos de minas,"
#      <------------------------------>
print "  usando el cursor."

elseif lang=english then

#      <------------------------------>
print  " You, the heroic lady. Cross"
#      <------------------------------>
print "  the minefields using the"
#      <------------------------------>
print "  the cursor keys."

elseif lang=interlingue then

#      <------------------------------>
print  " Tu, li heroic senioretta."
#      <------------------------------>
print "  Transea li campes de mines"
#      <------------------------------>
print "  usante li fleche-claves."

else // Esperanto

#      <------------------------------>
print  " Vi, la heroa fraŭlino."
#      <------------------------------>
print "  Trairu la min-kampojn"
#      <------------------------------>
print "  uzante la sago-klavojn."

endif

let i$=bill_udg$:gosub @icon

if lang=spanish then

#      <------------------------------>
print  " Bill el gusano: Está en el úl-"
#      <------------------------------>
print "  timo campo. Rescátalo."

elseif lang=english then

#      <------------------------------>
print  " Bill the worm: It's on the"
#      <------------------------------>
print "  last field. Rescue it."

elseif lang=interlingue then

#      <------------------------------>
print  " Bill li verme: It es in li"
#      <------------------------------>
print "  ultim camp. Salva it."

else // Esperanto

#      <------------------------------>
print  " Bill la vermo: Ĝi estas en la";
#      <------------------------------>
print "  lasta kampo. Savu ĝin."

endif

let i$=mine_udg$:gosub @icon

if lang=spanish then

#      <------------------------------>
print  " Minas: En la parte inferior"
#      <------------------------------>
print "  verás cuántas tienes cerca."

elseif lang=english then

#      <------------------------------>
print  " Mines: On the status bar you"
#      <------------------------------>
print "  will see how many of them are"
#      <------------------------------>
print "  near you."

elseif lang=interlingue then

#      <------------------------------>
print  " Mines: Sur li statu-barre tu"
#      <------------------------------>
print "  va vide quantes es apu te."

else // Esperanto

#      <------------------------------>
print  " Minoj: Sube de la ekrano vi"
#      <------------------------------>
print "  vidos kiomaj estas apud vi."

endif

# let i$="\h":gosub @icon
# #      <------------------------------>
# print  " La mina con patas:"
# #      <------------------------------>
# print "  Te perseguirá sin descanso."

let i$=fence_udg$:gosub @icon

if lang=spanish then

#      <------------------------------>
print  " Verja electrificada."

elseif lang=english then

#      <------------------------------>
print  " Electrified fence."

elseif lang=interlingue then

#      <------------------------------>
print  " Palissade electrificat."

else // Esperanto

#      <------------------------------>
print  " Elektrigita barilo."

endif

pause 0
randomize udg1:\
gosub @select_udg_set
return

// ==============================================================
// subrutine: texts

// Set the text translations

@texts

for i=1 to langs:\
  read lang,yes$(lang),no$(lang):\
next i

for i=1 to langs
  read lang
  do
    border 0
    read t
    if not t then exit do
    read t$:\
    let text$(lang,t)=t$:\
    let text_len(lang,t)=len(t$):\
    border 7
  loop
next i

return

data spanish,"S","N"
data english,"Y","N"
data interlingue,"Y","N"
data esperanto,"J","N"

data spanish

data title_txt,"   REGRESO AL CAMPO DE MINAS"
data instructions_txt,"Instrucciones"
data start_txt,"Jugar"
data credits_txt,"Créditos"
data change_language_txt,"No en español"
data level_txt,"Nivel"
data near_mines_txt,"Minas vecinas"
data points_txt,"Puntos"
data record_txt,"Récor"
data safe_zone_txt,"<<<<<<<< ZONA SEGURA >>>>>>>>>"
data putting_mines_txt,"Poniendo minas..."
data replay_controls_1_txt,"REPETICIÓN: [P]ausa [F]in"
data replay_controls_2_txt,"Una tecla para seguir"
data you_need_key_txt,"Necesitas la llave para salir"
data open_door_txt,"Puerta abierta"
data new_record_txt,"¡Un nuevo récord!"
data enter_initials_txt,"Introduce tus iniciales"
data again_txt,"¿Otra vez?"
data two_thousand_txt,"    ¡Dos mil puntos extra!"
data 0 // end of data

data english

data title_txt,"      BACK TO THE MINEFIELD"
data instructions_txt,"Instructions"
data start_txt,"Play"
data credits_txt,"Credits"
data change_language_txt,"Not in English"
data level_txt,"Level"
data near_mines_txt,"Near mines"
data points_txt,"Score"
data record_txt,"High"
data safe_zone_txt,"<<<<<<<<< SAFE ZONE >>>>>>>>>>"
data putting_mines_txt,"Putting mines..."
data replay_controls_1_txt,"REPETITION: [P]ause [F]inish"
data replay_controls_2_txt,"Any key to continue"
data you_need_key_txt,"Yo need the key to exit"
data open_door_txt,"Open door"
data new_record_txt,"A new record!"
data enter_initials_txt,"Enter your initials"
data again_txt,"Again?"
data two_thousand_txt,"   Two thousand extra points!"
data 0 // end of data

data interlingue

data title_txt,"   REVENIDA AL CAMP DE MINES"
data instructions_txt,"Instructiones"
data start_txt,"Luder"
data credits_txt,"Credites"
data change_language_txt,"Ne en Interlingue"
data level_txt,"Nivelle"
data near_mines_txt,"Mines proxim"
data points_txt,"Puntes"
data record_txt,"Record"
data safe_zone_txt,"<<<<<<<< ZONA SECUR >>>>>>>>>>"
data putting_mines_txt,"Colocante mines..."
data replay_controls_1_txt,"REPETITION: [P]ause [F]ine"
data replay_controls_2_txt,"Clavea por continuar"
data you_need_key_txt,"Tu besona li clave por exear"
data open_door_txt,"Porta apert"
data new_record_txt,"Un nov record!"
data enter_initials_txt,"Inscri vu initiales"
data again_txt,"Ancor?"
data two_thousand_txt,"     Du mil extra puntes!"
data 0 // end of data

data esperanto

data title_txt,"     REVENO AL LA MIN-KAMPO"
data instructions_txt,"Instrukcioj"
data start_txt,"Ludi"
data credits_txt,"Kreditoj"
data change_language_txt,"Ne en Esperanto"
data level_txt,"Nivelo"
data near_mines_txt,"Apudaj minoj"
data points_txt,"Poentoj"
data record_txt,"Rikordo"
data safe_zone_txt,"<<<<<<<< SEKURA ZONO >>>>>>>>>"
data putting_mines_txt,"Metante minojn..."
data replay_controls_1_txt,"RIPETO: [P]aŭzi [F]ini"
data replay_controls_2_txt,"Premu klavon por plui"
data you_need_key_txt,"Vi bezonas la ŝlosilon por eliri"
data open_door_txt,"Pordo malfermita"
data new_record_txt,"Nova rikordo!"
data enter_initials_txt,"Tajpu viajn inicialojn"
data again_txt,"Plu?"
data two_thousand_txt,"    Du mil kromaj poentoj!"
data 0 // end of data

// ==============================================================
// subroutine: icon

// Input:
// i$ = UDG string

@icon:
randomize udg1:\
gosub @select_udg_set:\
print 'bright 1;i$;:\
randomize udg_chars:\
goto @select_udg_set

// ==============================================================
// subroutine: select user defined characters

// Input: UDG set address stored in OS variable 23670.

@select_udg_set:

poke 23675,peek 23670:poke 23676,peek 23671:\
randomize:\
return

// ==============================================================
// subroutine: the_nest

@the_nest:

print at 4,4+ss;"\ :";\
      at 4,6+ss;"\: ";\
      at 5,4+ss;"\ :";\
      at 5,6+ss;"\: ";\
      at 6,4+ss;"\ :";\
      at 6,6+ss;"\: ";\
      at 7,1+ss;"\..\..\..\..";\
      at 7,6+ss;"\..\..\..\..";\
      at 9,1+ss;"\''\''\''\''";\
      at 9,6+ss;"\''\''\''\''";\
      at 10,4+ss;"\ :";\
      at 10,6+ss;"\: ";\
      at 11,4+ss;"\ :";\
      at 11,6+ss;"\: ";\
      at 12,4+ss;"\ :";\
      at 12,6+ss;"\: ":\
return

// ==============================================================
// subroutine: last level

// XXX TODO -- rewrite
// XXX FIXME --

@last_level:

let ss=int(rnd*11)+6
beep .3,-12

print at top_fence_row,door_col;fence$(1 to 3)

beep .3,-12
for n=0 to 1:\
  for m=0 to 6:\
    border n: beep .003,n*m: border m: beep .002,30+n+m*2:\
  next m:\
next n
border 2: flash 1
for n=0 to 9:\
  print at n+3,ss+1; paper paper_color; ink paper_color;"         ":\
next n
flash 0

for n=2 to -1 step -1
  beep .003,27-n: beep .003,19-n: beep .003,29-n
  if n>0 then \
    ink n
  if n=-1 then \
    flash 1: bright 0
  gosub @the_nest
next n
print at 11,5+ss; ink paper_color; paper paper_color;mine_udg$
flash 0
print at 8,5+ss; flash 0;bill_udg$
ink 0
return

// ==============================================================
// Sounds

// XXX TODO --

@sound:
for i=0 to 13:\
  read d: out 65333,i: out 49149,d:\
next i:\
return

@applause_sound:
data 0,0,0,0,0,0,30,64,15,16,15,0,7,24

@no_sound:
data 0,0,0,0,0,0,0,0,0,0,0,0,0,0

// ==============================================================
// Vimclair BASIC directives

# #tapmaker zmakebas
#tapmaker bas2tap

#filename DISK
#run 1

// ---------------------------------------------
//  Convert UTF-8 characters to UDG codes

# UDG set 2: Spanish:
#vim %substitute,á,\\A,gIe
#vim %substitute,Á,\\B,gIe
#vim %substitute,é,\\C,gIe
#vim %substitute,É,\\D,gIe
#vim %substitute,í,\\E,gIe
#vim %substitute,Í,\\F,gIe
#vim %substitute,ó,\\G,gIe
#vim %substitute,Ó,\\H,gIe
#vim %substitute,ú,\\I,gI
#vim %substitute,Ú,\\J,gIe
#vim %substitute,ñ,\\K,gIe
#vim %substitute,Ñ,\\L,gIe
#vim %substitute,ü,\\M,gIe
#vim %substitute,Ü,\\N,gIe
#vim %substitute,¿,\\O,gIe
#vim %substitute,¡,\\P,gIe
# %substitute,º,\\Q,gIe
#vim %substitute,«,\\R,gIe
#vim %substitute,»,\\S,gIe

# UDG set 3: Esperanto
#vim %substitute,Ĉ,\\A,gIe
#vim %substitute,ĉ,\\B,gIe
#vim %substitute,Ĝ,\\C,gIe
#vim %substitute,ĝ,\\D,gIe
#vim %substitute,Ĥ,\\E,gIe
#vim %substitute,ĥ,\\F,gIe
#vim %substitute,Ĵ,\\G,gIe
#vim %substitute,ĵ,\\H,gIe
#vim %substitute,Ŝ,\\I,gIe
#vim %substitute,ŝ,\\J,gIe
#vim %substitute,Ŭ,\\K,gIe
#vim %substitute,ŭ,\\L,gIe

// ---------------------------------------------
//  Shorten string variable names

#vim %substitute,\<mine_udg\$,a$,gIe
#vim %substitute,\<blank_row\$,b$,gIe
#vim %substitute,\<bill_udg\$,c$,gIe
#vim %substitute,\<mine_char\$,d$,gIe
#vim %substitute,\<fence\$,f$,gIe
#vim %substitute,\<flower_udg\$,g$,gIe
#vim %substitute,\<record_player\$,h$,gIe
#vim %substitute,\<fence_udg\$,j$,gIe
#vim %substitute,\<cursor_keys\$,k$,gIe
#vim %substitute,\<text\$,l$,gIe
#vim %substitute,\<replay_controls\$,m$,gIe
#vim %substitute,\<no\$,n$,gIe
#vim %substitute,\<key_udg\$,o$,gIe
#vim %substitute,\<protagonist\$,p$,gIe
#vim %substitute,\<dead_protagonist_udg\$,q$,gIe
#vim %substitute,\<trail\$,t$,gIe
#vim %substitute,\<blank_field_row\$,u$,gIe
#vim %substitute,\<version\$,v$,gIe
#vim %substitute,\<message\$,w$,gIe
#vim %substitute,\<yes\$,y$,gIe

// ---------------------------------------------
//  Shorten numeric array names

#vim %substitute,\<detector_color\>,d,gIe
#vim %substitute,\<text_len\>,l,gIe

// ---------------------------------------------
// Replace text identifiers and its count

#vim %substitute,\<again_txt\>,1,gIe
#vim %substitute,\<change_language_txt\>,2,gIe
#vim %substitute,\<credits_txt\>,3,gIe
#vim %substitute,\<enter_initials_txt\>,4,gIe
#vim %substitute,\<instructions_txt\>,5,gIe
#vim %substitute,\<level_txt\>,6,gIe
#vim %substitute,\<near_mines_txt\>,7,gIe
#vim %substitute,\<new_record_txt\>,8,gIe
#vim %substitute,\<open_door_txt\>,9,gIe
#vim %substitute,\<points_txt\>,10,gIe
#vim %substitute,\<putting_mines_txt\>,11,gIe
#vim %substitute,\<record_txt\>,12,gIe
#vim %substitute,\<replay_controls_1_txt\>,13,gIe
#vim %substitute,\<replay_controls_2_txt\>,14,gIe
#vim %substitute,\<safe_zone_txt\>,15,gIe
#vim %substitute,\<start_txt\>,16,gIe
#vim %substitute,\<title_txt\>,17,gIe
#vim %substitute,\<you_need_key_txt\>,18,gIe
#vim %substitute,\<two_thousand_txt\>,19,gIe

#vim %substitute,\<texts\>,19,gIe

// ---------------------------------------------
//  Shorten numeric variable names

#vim %substitute,\<border_color\>,bc,gIe
#vim %substitute,\<bottom_fence_row\>,bfr,gIe
#vim %substitute,\<bill_char\>,bh,gIe
#vim %substitute,\<back_surrounding_mines\>,bsm,gIe
#vim %substitute,\<bottom_safe_row\>,bsr,gIe
#vim %substitute,\<door_closed\>,dcl,gIe
#vim %substitute,\<door_col\>,dco,gIe
#vim %substitute,\<fence_char\>,fec,gIe
#vim %substitute,\<flower_char\>,fh,gIe
#vim %substitute,\<first_level\>,fl,gIe
#vim %substitute,\<found_char\>,foc,gIe
#vim %substitute,\<front_surrounding_mines\>,fsm,gIe
#vim %substitute,\<ink_color\>,ic,gIe
#vim %substitute,\<key_col\>,kc,gIe
#vim %substitute,\<key_char\>,kch,gIe
#vim %substitute,\<key_row\>,kr,gIe
#vim %substitute,\<last_level\>,ll,gIe
#vim %substitute,\<left_surrounding_mines\>,lsm,gIe
#vim %substitute,\<mine_char\>,mc,gIe
#vim %substitute,\<message_row\>,mr0,gIe
#vim %substitute,\<mine_row\>,mr1,gIe
#vim %substitute,\<mined_rows\>,mr2,gIe
#vim %substitute,\<next_text\>,nt,gIe
#vim %substitute,\<old_col\>,ocol,gIe
#vim %substitute,\<old_row\>,orow,gIe
#vim %substitute,\<paper_color\>,pc,gIe
#vim %substitute,\<protagonist_frame\>,pf,gIe
#vim %substitute,\<paused_replay\>,pr,gIe
#vim %substitute,\<record\>,r,gIe
#vim %substitute,\<right_surrounding_mines\>,rsm,gIe
#vim %substitute,\<score\>,s,gIe
#vim %substitute,\<start_col\>,sc,gIe
#vim %substitute,\<surrounding_mines\>,sm,gIe
#vim %substitute,\<top_fence_row\>,tfr,gIe
#vim %substitute,\<top_mined_row\>,tmr,gIe
#vim %substitute,\<time_score\>,ts,gIe
#vim %substitute,\<top_safe_row\>,tsr,gIe
#vim %substitute,\<texts\>,tx,gIe
#vim %substitute,\<udg1\>,u1,gIe
#vim %substitute,\<udg2\>,u2,gIe
#vim %substitute,\<udg3\>,u3,gIe
#vim %substitute,\<udg_chars\>,uc,gIe
#vim %substitute,\<udg1_font\>,uf,gIe
#vim %substitute,\<udg1_font_high\>,uh,gIe
#vim %substitute,\<udg1_font_low\>,ul,gIe
#vim %substitute,\<walking_mine_col\>,wmc,gIe
#vim %substitute,\<walking_mine_row\>,wmr,gIe
#vim %substitute,\<walking_mine_step\>,wms,gIe

// ---------------------------------------------
//  Shorten function names

#vim %substitute,\<\(\(def\)\?\s*fn \)\+random_row\>,\1 r,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+random_col\>,\1 c,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+txt\$,\1 t$,gIe

// vim: filetype=vimclairbasic:fileencoding=utf8
