rem Back to the minefield
//
//  Written in Vimclair BASIC for ZX Spectrum 128.
//
rem By Marcos Cruz (programandala.net), 2016, 2017, 2018, 2019.
//
//  Based on "Campo de minas" (published by Indescomp), the Spanish
//  version of "Minefield", written by Ian Andrew.

// ==============================================================
// Start {{{1

border 0: paper 0: ink 0: flash 0: inverse 0: bright 0:\
clear 65535-21*8*3-8:\

let version$="0.83.3+201903251226":\
// Note: version number after Semantic Versioning: http://semver.org

goto @init

// ==============================================================
// Functions {{{1

// A random row of the field:
deffn random_row()=int(rnd*mined_rows)+top_mined_row

// A random column of the field:
deffn random_col()=int(rnd*30)+1

// Text number n in the current language:
deffn txt$(n)=text$(lang,n,1 to text_len(lang,n))

// Current count of the system frames counter, in seconds:
deffn seconds()=int((peek 23672+256*peek 23637+65536*peek 23674)/50)

// Score in a 5-character string, with zeros at the left:
deffn score$(n)="00000"(to 5-len str$ n)+str$ n

// ==============================================================
// Start a new game {{{1

@new_game:

let level=first_level:\
let score=0

// ==============================================================
// Enter a new level {{{1

@new_level:

randomize udg1:\
gosub @select_udg_set

let surrounding_mines=0:\
let door_closed=0

// coordinates
let row=bottom_fence_row:\
let col=start_col:\
let old_row=row:\
let old_col=col

// list of coordinates, stored as chars
let trail$=chr$ row+chr$ col

// counter
let enter_time=fn seconds()

let protagonist_frame=0:\

let walking_mine_step=-1:\
let walking_mine_row=row:\
let walking_mine_col=col:\
let pa=7

let paper_color=7-level:\
let mines=32+level*4

border border_color:\
paper paper_color:\
ink ink_color:\
cls:\
gosub @no_message:\
load!"fence.scr"code

let message$=fn txt$(putting_mines_txt):\
gosub @message

print paper 8;bright 1;\
  at top_fence_row+1,1;fn txt$(safe_zone_txt);\
  at bottom_fence_row-1,1;fn txt$(safe_zone_txt)

for w=1 to mines:\
  print \
    at fn random_row(),fn random_col();\
    ink paper_color;mine_udg$:\
  beep .0015,35:\
next w

print paper 8;\
  at top_fence_row+1,1;blank_field_row$;\
  at bottom_fence_row-1,1;blank_field_row$

gosub @no_message:\
gosub @new_status_bar

let flowers=0

if level=last_level then

  gosub @last_level

else

  let flowers=int(rnd*(level+2))
  if flowers then
    dim flower_row(flowers):\
    dim flower_col(flowers)
    for i=1 to flowers:\
      let flower_row(i)=fn random_row():\
      let flower_col(i)=fn random_col():\
      print at flower_row(i),flower_col(i);flower_udg$:\
    next i
  endif

endif

if level=(last_level-1) then \
  gosub @close_the_door

beep .0875,10

for n=1 to 20
  beep .002,n+20
next n
# print at 21,4;"         ": beep .05,37
goto @l535

@l500:

let old_row=row:\
let old_col=col

do

  let i=peek 23560:\
  poke 23560,0:\
  let row=row+(i=10)-(i=11):\
  let row=row-(row=(bottom_fence_row+1)):\
  let col=col+(i=9)-(i=8)

  // XXX OLD -- improve or remove
  # if level>=4 then \
  #   if time>(260*paper_color+70) then \
  #     if int(time/(3*paper_color+1))=(time/(3*paper_color+1)) then \
  #       gosub @walking_mine

loop while old_row=row and old_col=col

beep .003,-4

@l535:

print at old_row,old_col; paper pa;" "
let trail$=trail$+chr$ row+chr$ col

// XXX TODO -- move down to save the print
if door_closed then \
    if row=key_row then \
      if col=key_col then \
        print at row,col; paper pa;protagonist$(protagonist_frame+1):\
        let protagonist_frame=not protagonist_frame:\
        gosub @open_the_door:\
        goto @step_done

// make the first UDG bank the current font, in order to detect
// the graphics with `screen$()`:
poke 23606,udg1_font_low:poke 23607,udg1_font_high:\

// XXX REMAK -- There's a bug in Sinclar BASIC: the following
// calculations return a wrong non-integer value. That's why every
// value is calculated apart.

# let surrounding_mines=int(\
#   (screen$(row-1,col)<>" ")+\
#   (screen$(row+1,col)<>" ")+\
#   (screen$(row,col-1)<>" ")+\
#   (screen$(row,col+1)<>" "))

# let surrounding_mines=(screen$(row-1,col)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row+1,col)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row,col-1)<>" ")
# let surrounding_mines=surrounding_mines+(screen$(row,col+1)<>" ")

let found_char=code screen$(row,col):\
let front_surrounding_mines=screen$(row-1,col)=mine_char$:\
let back_surrounding_mines=screen$(row+1,col)=mine_char$:\
let left_surrounding_mines=screen$(row,col-1)=mine_char$:\
let right_surrounding_mines=screen$(row,col+1)=mine_char$:\

// restore the default font:
poke 23606,0:poke 23607,60

if found_char=mine_char then \
  goto @explosion

if found_char=fence_char then \
  goto @explosion

if found_char=flower_char then
  let score=score+10:\
  gosub @update_status_bar
elseif found_char=bill_char then
  gosub @rescue
endif

print at row,col; paper pa;protagonist$(protagonist_frame+1):\
let protagonist_frame=not protagonist_frame

@step_done:

let surrounding_mines=\
  front_surrounding_mines+\
  back_surrounding_mines+\
  left_surrounding_mines+\
  right_surrounding_mines:\
gosub @print_surrounding_mines:\
beep .04*sgn surrounding_mines,surrounding_mines*10

if row=top_fence_row then \
  goto @level_passed

goto @l500

// ==============================================================
// subroutine: close the door {{{1

@close_the_door:

let key_row=fn random_row():\
let key_col=fn random_col():\
print at key_row,key_col;key_udg$:\

let message$=fn txt$(you_need_key_txt):\
gosub @message

for i=60 to 10 step -5:\
  print at top_fence_row,door_col;"   ":\
  beep .125,i:\
  print at top_fence_row,door_col;fence$(1 to 3):\
  for j=1 to 7: next j:\
next i:\
gosub @no_message:\
let door_closed=1:\
return

// ==============================================================
// subroutine: open the door {{{1

@open_the_door:

let message$=fn txt$(open_door_txt):\
gosub @message:\
for i=10 to 60 step 5:\
  print at top_fence_row,door_col;fence$(1 to 3):\
  beep .125,i:\
  print at top_fence_row,door_col;"   ":\
  for j=1 to 7: next j:\
next i:\
gosub @no_message:\
let door_closed=0:\
return

// ==============================================================
// subroutine: status bar {{{1

@new_status_bar:

input ;:\
randomize udg_chars:\
gosub @select_udg_set:\
print #1;paper 0;ink 7;\
  at 0, 0;fn txt$(level_txt);inverse 1;\
  at 1, 0;"     ";inverse 0;\
  at 0, 8;fn txt$(near_mines_txt);\
  at 0,16;fn txt$(points_txt);inverse 1;\
  at 1,16;" 00000 ";inverse 0;\
  at 0,25;fn txt$(record_txt);inverse 1;\
  at 1,25;" 00000 ";:\
randomize udg1:\
gosub @select_udg_set

@update_status_bar:

// XXX FIXME -- A system or emulator bug?: only the first item is
// affected by `paper` and `ink`, the rest is printed with the current
// colors. The problem is solved by removing `str$` in the expression.
// In fact, using `str$` to calculate the column of the first
// expression, makes this one be printed with default colors too.

# print #1;paper 2;ink 0;\
#   at 1,2;level;\
#   at 1,22-len str$ score;score;\
#   at 1,31-len str$ record;record

// XXX FIXME -- This alternative prints score and record with inverse
// colors! `str$` is used in the function that calculates the string.

print #1;paper 7;ink 0;\
  at 1,2;level;\
  at 1,17;fn score$(score);\
  at 1,26;fn score$(record)

# XXX FIXME -- This makes no difference:

# print #1;paper 7;ink 0;\
#   at 1,2;level;\
#   at 1,17;paper 7;ink 0;fn score$(score);\
#   at 1,26;paper 7;ink 0;fn score$(record)

@print_surrounding_mines:

print #1; paper detector_color(surrounding_mines+1);ink 9;\
  at 1,8;"  ";surrounding_mines;"  ":\
return

// ==============================================================
// subroutine: walking mine {{{1

// XXX TODO -- improve or remove

@walking_mine:

// XXX TODO -- try, after the latest changes (2016-06-12)

print at walking_mine_row,walking_mine_col; paper pa;" "

let walking_mine_step=walking_mine_step+2:\
beep .0018,60
let walking_mine_row=code trail$(walking_mine_step):\
let walking_mine_col=code trail$(walking_mine_step+1):\
if screen$(walking_mine_row,walking_mine_col)<>" " then \
  goto @explosion

// XXX TODO -- improve:
print at walking_mine_row,walking_mine_col; paper pa;"\h":\
return

// ==============================================================
// explosion {{{1

@explosion:

// XXX TODO -- remove mine count from the status bar

for i=20 to 1 step -1:\
  beep .003,i: print at row,col;"\c":\
  beep .002,10: print at row,col;dead_protagonist_udg$:\
next i
beep 1.6,-35
if found_char=mine_char then
  print at row,col;mine_udg$
else
  print at row,col;fence_udg$
endif
gosub @replay

if not quit_replay then:\
  print at row,col;dead_protagonist_udg$:\
  beep 1,-35

if score>record then \
  gosub @new_record
gosub @update_status_bar

let message$=fn txt$(press_key_text):\
gosub @message:\

pause 0:\
goto @menu

// ==============================================================
// subroutine: message {{{1

@message:

gosub @no_message:\
randomize udg_chars:\
gosub @select_udg_set:\
print bright 1; ink 9; paper border_color;\
  at message_row,(32-len message$)/2;message$;:\
randomize udg1:\
gosub @select_udg_set:\
return

@no_message:

print at message_row,0;paper border_color;blank_row$;:\
return

// ==============================================================
// Rescue {{{1

@rescue:

# XXX OLD
# gosub @the_nest
# let dx=30
# for u=.155 to .005 step -.01
#   print at 0,dx; ink 0; paper 7;"\n "
#   let dx=dx-1
#   beep u,8: beep u,12: beep u,16
#   border rnd*7
# next u
# for n=1 to 16
#   print at 0,dx; ink 0; paper 7;"\n "
#   let dx=dx-1+(dx=0)
#   beep u+.005,8
#   border rnd*7
#   beep u+.005,12: beep u,16
# next n
# print at 0,0; paper 7;" "
# for t=0 to 2
#   for l=0 to 7 step 7
#     ink l
#     // XXX TODO -- simpler
#     for n=1 to 5:\
#       print at row+n,col+n;"*":\
#       print at row-n,col+n;"*":\
#       print at row+n,col-n;"*":\
#       print at row-n,col-n;"*":\
#     next n
#     for n=1 to 5:\
#       print at row,col+n;">":\
#       print at row,col-n;"<":\
#       print at row+n,col;"#":\
#       print at row-n,col;"#":\
#     next n
#   next l
# next t
# ink 0
# gosub @the_nest

print at 0,0; ink 7; paper 0;\
text$(lang,two_thousand_txt);

let score=score+2000:\
gosub @update_status_bar

# XXX OLD
# for b=0 to 7
#   paper b: ink 9
#   print at row,col;protagonist$(protagonist_frame+1):\
#   let protagonist_frame=not protagonist_frame
#   for n=1 to 14
#     beep .002,50-n+b
#     border 1: border 2: border 3: border 4
#     border 5: border 6: border 7: border b
#   next n
# next b

border 0: paper 0: cls

# XXX OLD
# for n=0 to 30 step 6
#   for m=1 to 10
#     beep .008,n+m
#   next m
# next n

if lang=spanish then

#  <------------------------------>
print at 3,8;\
  "¡Felicidades!"
#  <------------------------------>
print '\
  "Has rescatado a Bill. El mundo"'\
  "te está agradecido."
#  <------------------------------>
print '\
  "Puntuación: ";score;"."
#  <------------------------------>
print '\
  "¿Por qué no vuelves a jugar y"'\
  "tratas de mejorarla?"
#  <------------------------------>

elseif lang=english then

#  <------------------------------>
print at 3,6;\
  "Congratulations!"
#  <------------------------------>
print '\
  "You have rescued Bill. The"'\
  "world thanks you."
#  <------------------------------>
print '\
  "Score: ";score;"."
#  <------------------------------>
print '\
  "Why don't you play again and"'\
  "try to do it even better?"
#  <------------------------------>

elseif lang=interlingue then

// XXX TODO --

#  <------------------------------>
print at 3,6;\
  "Gratulationes!"
#  <------------------------------>
print '\
  "Tu hat salvat Bill. Li munde"'\
  "mersia te."
#  <------------------------------>
print '\
  "Pontes: ";score;"."
#  <------------------------------>
print '\
  "Mey tu luder ancor e provar far"'\
  "it mem plu bon?"
#  <------------------------------>

else // Esperanto

#  <------------------------------>
print at 3,6;\
  "Gratulon!"
#  <------------------------------>
print '\
  "Vi savis Bill. La mondo dankas"'\
  "vin."
#  <------------------------------>
print '\
  "Poentoj: ";score;"."
#  <------------------------------>
print '\
  "Kial ne ludi plian fojon kaj"'\
  "klopodi fari eĉ pli bone?"
#  <------------------------------>

endif

// XXX FIXME -- This is not the best place for this, given the
// previous messages:
if score>record then \
  gosub @new_record

pause 0:\
goto @menu

// ==============================================================
// subroutine: replay {{{1

@replay:

let quit_replay=0 // exit flag

// XXX FIXME -- remove the surrounding mines
// XXX FIXME -- when the replay is ended, the explosion is shown in the
// current position!

// XXX TODO --
# print at walking_mine_row,walking_mine_col;" ";\
#       at row,col;" "

// Make all mines visible and hide the path:
load!str$ paper_color code

// Restore all the flowers:
for i=1 to flowers:\
  print at flower_row(i),flower_col(i);\
    paper 8;ink 8;\
    flower_udg$:\
next i

randomize udg_chars:\
gosub @select_udg_set

let paused_replay=0:\
gosub @show_replay_bar

randomize udg1:\
gosub @select_udg_set

for n=1 to 100: next n

let row=code trail$(1):\
let col=code trail$(2)

for t=1 to len trail$ step 2

@replay_control:

  // XXX REMARK -- At the moment the control keys must be the same in
  // all languages (P to pause and F to finish).

  let i$=inkey$
  if paused_replay then
    let paused_replay=(i$=""):\
    beep .1*not paused_replay,0:\
    if paused_replay then \
      goto @replay_control
    gosub @show_replay_bar
  endif
  if i$="f" or i$="F" then \
    let quit_replay=1:\
    goto @quit_replay
  if i$="p" or i$="P" then \
    let paused_replay=1:\
    beep .1,10:\
    gosub @show_replay_bar

  print at row,col; paper 7;" "
  let row=code trail$(t):\
  let col=code trail$(t+1):\
  print at row,col; paper 7;protagonist$(protagonist_frame+1):\
  let protagonist_frame=not protagonist_frame
  beep .005,5+(t*40/(len trail$))

next t

@quit_replay:

gosub @no_message:\
return

@show_replay_bar:

let message$=fn txt$(replay_controls_1_txt+paused_replay):\
  gosub @message:\
return

// ==============================================================
// subroutine: level passed {{{1

@level_passed:

let surrounding_mines=0:\
gosub @print_surrounding_mines

// XXX TODO -- improve time score with the frames system variable

let exit_time=fn seconds():\
let time_score=600-(exit_time-enter_time):\
let time_score=time_score*(time_score>0)*level

// XXX TODO --
# restore @applause_sound:\
# gosub @sound

paper pa
poke 23560,0:\
for i=1 to 8:\
  print at row,col;protagonist$(1):\
  if peek 23560 then goto @level_replay
  beep .1,0:\
  print at row,col;protagonist$(2):\
  beep .1,10:\
  if peek 23560 then goto @level_replay
next i

@level_replay:

// XXX TODO --
# restore @no_sound:\
# gosub @sound

print at row,col;" "

gosub @replay

// XXX OLD
// XXX TODO -- Write other effect?
# for i=4 to 22 step 6:\
#   beep .005,i+24:\
# next i
# for i=1 to 8:\
#   for j=1 to 6:\
#     print at message_row,0;paper j;blank_row$;:\
#     border j:\
#   next j:\
# next i:\
# print at message_row,0;paper 0;blank_row$;:\
# border border_color

// XXX TODO -- variable to flash the score
let score=score+time_score+mines:\
gosub @update_status_bar

let level=level+1:\
goto @new_level

// ==============================================================
// subroutine: new record {{{1

@new_record:

// XXX TMP --
let record=score:return

// XXX TODO -- rewrite:

for n=1 to 50
  border 1: border 2: border 3: border 4
next n
for n=1 to 50
  border 6: border 2: beep .002,40+(n/10): border 6
next n
randomize udg_chars:\
gosub @select_udg_set
for m=1 to 4
  for n=7 to 0 step -1
    print at 10,7; ink n;fn txt$(new_record_txt)
    beep .004,50-n
  next n
next m
print at 10,7; ink 9;fn txt$(new_record_txt)
randomize udg1:\
gosub @select_udg_set

// XXX TODO -- adapt

print at 21,0;\
  flash 1; paper 1; ink 7;\
  fn txt$(enter_initials_txt); flash 0;"         "

let record_player$="   "
for n=1 to 3
  do
    let record_player$(n)=inkey$
  loop while record_player$(n)=" "
  if record_player$(n)>="a" and record_player$(n)<="z" then \
    let record_player$(n)=chr$((code record_player$(n))-32)
  print at 21,24+n; ink 7; paper 1;record_player$(n)
  beep .12,(n*5)+20
  for m=1 to 4: next m
next n
let record=score
for n=1 to 12
  beep .0045,-10: border 1: border 2: border 6: border 4
next n
border border_color
beep .1,8
for n=1 to 4: next n
beep .1,8: beep .1,8: beep .1,20: beep .1,24: beep .1,18: beep .15,29
for n=1 to 7: next n
beep .12,22
for n=1 to 3: next n
beep .07,19: beep .08,17
for n=1 to 3: next n
beep .1,14: beep .1,12
print at 10,7;"                  "
return

// ==============================================================
// init {{{1

@init:

// ---------------------------------------------
// OS variables {{{2

// Set the REPDEL OS variable (at memory address 23561) to zero, for
// speed.
//
// REPDEL contains the time (in 50ths of a second) that a key must be
// held down before it repeats.  Its default value is 35.

poke 23561,0

// ---------------------------------------------
// Graphics {{{2

// There are three UDG banks:
//
// udg1: graphics
// udg2: the Spanish and Interlingue characters
// udg3: the Esperanto characters

let udg1=65535-21*8*3:\
let udg2=udg1+21*8:\
let udg3=udg2+21*8:\
let udg_chars=udg2:\
load "UDG.BIN" code udg1-8
let udg1_font=udg1-256-8:\
let udg1_font_high=int(udg1_font/256):\
let udg1_font_low=udg1_font-(udg1_font_high*256)

// ---------------------------------------------
// Constants {{{2

let first_level=1 // XXX TMP -- change for debugging -- default=1
let last_level=7

let message_row=0:\
let top_fence_row=1:\
let bottom_fence_row=21:\
let top_safe_row=top_fence_row+1:\
let top_mined_row=top_safe_row+1:\
let bottom_safe_row=bottom_fence_row-1:\
let mined_rows=bottom_safe_row-top_safe_row-1:\
let door_col=14:\
let start_col=15

let blank_row$="                                "

dim protagonist$(2):\
let protagonist$="\d\e":\
let dead_protagonist_udg$="\l":\

let bill_char=46:\
let bill_udg$="\n":\
let fence_char=38:\
let fence_udg$="\f":\
let flower_char=49:\
let flower_udg$="\q":\
let key_char=48:\ // XXX TODO -- Not used.
let key_udg$="\p":\
let mine_char$="/":\
let mine_char=47:\
let mine_udg$="\o"

let fence$="\f\f\f\f\f\f\f\f\f\f\f\f\f\f   \f\f\f\f\f\f\f\f\f\f\f\f\f\f\f"

let blank_field_row$="                              "

let ink_color=9

dim detector_color(4):\
let detector_color(1)=4:\
let detector_color(2)=5:\
let detector_color(3)=6:\
let detector_color(4)=2

// ---------------------------------------------
// Variables {{{2

let record_player$="IAN":\
let record=250

// ---------------------------------------------
// Languages {{{2

// Defined in alphabetical order of their original names:

let english=1:\     // English
let spanish=2:\     // Español
let esperanto=3:\   // Esperanto
let interlingue=4:\ // Interlingue

let langs=4

// ---------------------------------------------
// Multilingual texts {{{2

dim text$(langs,texts,32):\
dim text_len(langs,texts):\
dim yes$(langs):\
dim no$(langs)

gosub @texts:\
let lang=english

// ---------------------------------------------
// Files {{{2

// Some files are created in the RAM disc in order to accelerate the
// drawing at run-time.

// .............................
// Fence {{{3

// Draw the fence and save the display (without attributes) into a
// file, which which will used to update the display instantaneously.

randomize udg1:\
gosub @select_udg_set:\
print at top_fence_row,0;fence$:\
for n=top_safe_row to bottom_safe_row:\
  border 7:\
  print at n,0;\
    fence_udg$+"                              "+fence_udg$:\
  border 0:\
next n:\
print at bottom_fence_row,0;fence$:\
save!"fence.scr"code 16384,6144

// .............................
// Arena attributesa {{{3

// Save the attributes of the field background (rows from 1 to 21), in
// all colors, into files.  The files are named with the digit of the
// color. They are used to restore the field before the replay.

ink 0:\
for n=7 to 0 step -1:\
  paper n:\
  cls:\
  save!str$ n code 22560,672:\
next n

// ==============================================================
// menu {{{1

@menu:

border 1: paper 1: ink 7:\
cls

print \
  at 2,0;"_____________";\
  at 12,0;"________________________________";\
  at 20,19;"_____________"

// Alternative with full width rulers:
# print \
#   at  2,0;"________________________________";\
#   at 12,0;"________________________________";\
#   at 20,0;"________________________________";

# <------------------------------>
print #1;\
  at 0,9;"{(C)} Marcos Cruz";\
  at 1,1;"(programandala.net), 2016-2019"
# <------------------------------>

@update_languages:

// Select the UDG set containing the Spanish chars,
// no matter the current language, because only
// that set is needed to print the list of languages:
randomize udg2:\
gosub @select_udg_set

print at 4,0'\
  inverse lang<>english;english;inverse 0;" ";\
  bright lang=english;"English";bright 0;''\
  inverse lang<>spanish;spanish;inverse 0;" ";\
  bright lang=spanish;"Español";bright 0;''\
  inverse lang<>esperanto;esperanto;inverse 0;" ";\
  bright lang=esperanto;"Esperanto";bright 0;''\
  inverse lang<>interlingue;interlingue;inverse 0;" ";\
  bright lang=interlingue;"Interlingue";bright 0

@update_options:

// Select the UDG set needed by the current language:
randomize udg_chars:\
gosub @select_udg_set

print at 0,0;text$(lang,title_txt)

print \
at 15,19;inverse 1;text$(lang,instructions_txt,1);\
  inverse 0;text$(lang,instructions_txt,2 to 13);\
at 17,19;inverse 1;text$(lang,start_txt,1);\
  inverse 0;text$(lang,start_txt,2 to 13);\
at 19,19;inverse 1;text$(lang,credits_txt,1);\
  inverse 0;text$(lang,credits_txt,2 to 13)

@menu_key

// Wait for a key and convert it to uppercase
// if needed:
pause 0:let i$=inkey$:\
if i$>"Z" then \
  let i$=chr$(code(i$)-32)

// Instructions?
if i$=text$(lang,instructions_txt,1) then \
  gosub @instructions:\
  goto @menu

// Play?
if i$=text$(lang,start_txt,1) then \
  goto @new_game

// Credits?
if i$=text$(lang,credits_txt,1) then \
  gosub @credits:\
  goto @menu

// Language number?
if i$>="1" and i$<=chr$(code "0"+langs) then
  if lang=val i$ then \
    goto @invalid_key
  let lang=val i$
  if lang=esperanto then
    let udg_chars=udg3
  else
    let udg_chars=udg2
  endif
  goto @update_languages
endif

@invalid_key:
beep .1 ,23:\
goto @menu_key

// ==============================================================
// subroutine: credits {{{1

@credits:

cls
randomize udg_chars:\
gosub @select_udg_set
print text$(lang,title_txt)''

if lang=spanish then

#      <------------------------------>
print "Versión:"''
print "  ";version$
print
print "Autor:"''
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Jugador de pruebas:"''
print "  Irene Albert."
print
print "Un homenaje a y una reinterpre-"
print "tación de:"''
print "  Minefield (Ian Andrew, 198x)."
print
print "Escrito en Vimclair BASIC para"
print "ZX Spectrum 128."
#      <------------------------------>

elseif lang=english then

#      <------------------------------>
print "Version:"''
print "  ";version$
print
print "Author:"''
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Test player:"''
print "  Irene Albert."
print
print "A tribute to and a reinterpre-"
print "tation of:"''
print "  Minefield (Ian Andrew, 198x)."
print
print "Written in Vimclair BASIC for"
print "ZX Spectrum 128."
#      <------------------------------>

elseif lang=interlingue then

#      <------------------------------>
print "Version:"''
print "  ";version$
print
print "Autor:"''
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Lusor de provas:"''
print "  Irene Albert."
print
#      <------------------------------>
print "Un tribute e un reinterpreta-"
print "tion ye:"''
print "  Minefield (Ian Andrew, 198x)."
print
print "Scrit in Vimclair BASIC por ZX"
print "Spectrum 128."
#      <------------------------------>

elseif lang=esperanto then

#      <------------------------------>
print "Versio:"''
print "  ";version$
print
print "Aŭtoro:"''
print "  Marcos Cruz"
print "  (programandala.net), 2016-2019"
print
print "Provludanto:"''
print "  Irene Albert."
print
print "Omaĝo kaj reinterpreto je:"''
print "  Minefield (Ian Andrew, 198x)."
print
print "Verkita en Vimclair BASIC por ZX"
print "Spectrum 128."
#      <------------------------------>

endif

randomize udg1:\
gosub @select_udg_set
pause 0
return

// ==============================================================
// subroutine: icon {{{1

// Input:
// i$ = UDG string

@icon:
randomize udg1:\
gosub @select_udg_set:\
print 'bright 1;i$;:\
randomize udg_chars:\
goto @select_udg_set

// ==============================================================
// subroutine: instructions {{{1

@instructions:

cls:\
print text$(lang,title_txt)

if lang=spanish then

let i$=protagonist$(1):gosub @icon
#      <------------------------------>
print  " Tú, la heroica damisela. Atra-";
print "  viesa los campos de minas,"
print "  usando el cursor."
let i$=bill_udg$:gosub @icon
#      <------------------------------>
print  " Bill el gusano: Está en el úl-"
print "  timo campo. Rescátalo."
let i$=mine_udg$:gosub @icon
#      <------------------------------>
print  " Minas: En la parte inferior"
print "  verás cuántas tienes cerca."
let i$=fence_udg$:gosub @icon
#      <------------------------------>
print  " Verja electrificada."

elseif lang=english then

let i$=protagonist$(1):gosub @icon
#      <------------------------------>
print  " You, the heroic damsel. Cross"
print "  the minefields using the"
print "  the cursor keys."
let i$=bill_udg$:gosub @icon
#      <------------------------------>
print  " Bill the worm: It's on the"
print "  last field. Rescue it."
let i$=mine_udg$:gosub @icon
#      <------------------------------>
print  " Mines: On the status bar you"
print "  will see how many of them are"
print "  near you."
let i$=fence_udg$:gosub @icon
#      <------------------------------>
print  " Electrified fence."

elseif lang=interlingue then

let i$=protagonist$(1):gosub @icon
#      <------------------------------>
print  " Tu, li heroic senioretta."
print "  Transea li campes de mines"
print "  usante li fleche-claves."
let i$=bill_udg$:gosub @icon
#      <------------------------------>
print  " Bill li verme: It es in li"
print "  ultim camp. Salva it."
let i$=mine_udg$:gosub @icon
#      <------------------------------>
print  " Mines: Sur li statu-barre tu"
print "  va vider quantes es apu te."
let i$=fence_udg$:gosub @icon
#      <------------------------------>
print  " Palissade electrificat."

else // Esperanto

let i$=protagonist$(1):gosub @icon
#      <------------------------------>
print  " Vi, la heroa fraŭlino."
print "  Trairu la min-kampojn"
print "  uzante la sago-klavojn."
let i$=bill_udg$:gosub @icon
#      <------------------------------>
print  " Bill la vermo: Ĝi estas en la"
print "  lasta kampo. Savu ĝin."
let i$=mine_udg$:gosub @icon
#      <------------------------------>
print  " Minoj: Sube de la ekrano vi"
print "  vidos kiomaj estas apud vi."
let i$=fence_udg$:gosub @icon
#      <------------------------------>
print  " Elektrigita barilo."

endif

pause 0
randomize udg1:\
gosub @select_udg_set
return

// ==============================================================
// subrutine: texts {{{1

// Set the text translations

@texts

for i=1 to langs:\
  read lang,yes$(lang),no$(lang):\
next i

for i=1 to langs
  read lang
  do
    border 0
    read t
    if not t then exit do
    read t$:\
    let text$(lang,t)=t$:\
    let text_len(lang,t)=len(t$):\
    border 7
  loop
next i

return

data spanish,"S","N"
data english,"Y","N"
data interlingue,"Y","N"
data esperanto,"J","N"

data spanish

data title_txt,"   REGRESO AL CAMPO DE MINAS"
data instructions_txt,"Instrucciones"
data start_txt,"Jugar"
data credits_txt,"Créditos"
data change_language_txt,"No en español"
data level_txt,"Campo"
data near_mines_txt,"Minas"
data points_txt,"Puntos"
data record_txt,"Récor"
data safe_zone_txt,"<<<<<<<< ZONA SEGURA >>>>>>>>>"
data putting_mines_txt,"Poniendo minas..."
data replay_controls_1_txt,"REPETICIÓN: [P]ausa [F]in"
data replay_controls_2_txt,"Una tecla para seguir"
data you_need_key_txt,"Necesitas la llave para salir"
data open_door_txt,"Puerta abierta"
data new_record_txt,"¡Un nuevo récord!"
data enter_initials_txt,"Introduce tus iniciales"
data press_key_text,"Pulsa una tecla para ir al menú"
data two_thousand_txt,"    ¡Dos mil puntos extra!"
data 0 // end of data

data english

data title_txt,"      BACK TO THE MINEFIELD"
data instructions_txt,"Instructions"
data start_txt,"Play"
data credits_txt,"Credits"
data change_language_txt,"Not in English"
data level_txt,"Field"
data near_mines_txt,"Mines"
data points_txt,"Score"
data record_txt,"High"
data safe_zone_txt,"<<<<<<<<< SAFE ZONE >>>>>>>>>>"
data putting_mines_txt,"Putting mines..."
data replay_controls_1_txt,"REPETITION: [P]ause [F]inish"
data replay_controls_2_txt,"Any key to continue"
data you_need_key_txt,"Yo need the key to exit"
data open_door_txt,"Open door"
data new_record_txt,"A new record!"
data enter_initials_txt,"Enter your initials"
data press_key_text,"Press any key to go to the menu"
data two_thousand_txt,"   Two thousand extra points!"
data 0 // end of data

data interlingue

data title_txt,"   REVENIDA AL CAMP DE MINES"
data instructions_txt,"Instructiones"
data start_txt,"Luder"
data credits_txt,"Credites"
data change_language_txt,"Ne en Interlingue"
data level_txt,"Campo"
data near_mines_txt,"Mines"
data points_txt,"Puntes"
data record_txt,"Record"
data safe_zone_txt,"<<<<<<<< ZONA SECUR >>>>>>>>>>"
data putting_mines_txt,"Colocante mines..."
data replay_controls_1_txt,"REPETITION: [P]ause [F]ine"
data replay_controls_2_txt,"Clavea por continuar"
data you_need_key_txt,"Tu besona li clave por exear"
data open_door_txt,"Porta apert"
data new_record_txt,"Un nov record!"
data enter_initials_txt,"Inscri vu initiales"
data press_key_text,"Presse un clave por ear li menú"
data two_thousand_txt,"     Du mil extra puntes!"
data 0 // end of data

data esperanto

data title_txt,"     REVENO AL LA MIN-KAMPO"
data instructions_txt,"Instrukcioj"
data start_txt,"Ludi"
data credits_txt,"Kreditoj"
data change_language_txt,"Ne en Esperanto"
data level_txt,"Kampo"
data near_mines_txt,"Minoj"
data points_txt,"Poentoj"
data record_txt,"Rikordo"
data safe_zone_txt,"<<<<<<<< SEKURA ZONO >>>>>>>>>"
data putting_mines_txt,"Metante minojn..."
data replay_controls_1_txt,"RIPETO: [P]aŭzi [F]ini"
data replay_controls_2_txt,"Premu klavon por plui"
data you_need_key_txt,"Vi bezonas la ŝlosilon por eliri"
data open_door_txt,"Pordo malfermita"
data new_record_txt,"Nova rikordo!"
data enter_initials_txt,"Tajpu viajn inicialojn"
data press_key_text,"Premu klavon por iri al la menuo"
data two_thousand_txt,"    Du mil kromaj poentoj!"
data 0 // end of data

// ==============================================================
// subroutine: select user defined characters {{{1

// Input: UDG set address stored in OS variable 23670.

@select_udg_set:

poke 23675,peek 23670:poke 23676,peek 23671:\
randomize:\
return

// ==============================================================
// subroutine: the_nest {{{1

@the_nest:

print at nest_row,nest_col+3;fence_udg$;\
      at nest_row,nest_col+5;fence_udg$;\
      at nest_row+1,nest_col+3;fence_udg$;\
      at nest_row+1,nest_col+5;fence_udg$;\
      at nest_row+2,nest_col+3;fence_udg$;\
      at nest_row+2,nest_col+5;fence_udg$;\
      at nest_row+3,nest_col;fence$(1 to 4);\
      at nest_row+3,nest_col+5;fence$(1 to 4);\
      at nest_row+5,nest_col;fence$(1 to 4);\
      at nest_row+5,nest_col+5;fence$(1 to 4);\
      at nest_row+6,nest_col+3;fence_udg$;\
      at nest_row+6,nest_col+5;fence_udg$;\
      at nest_row+7,nest_col+3;fence_udg$;\
      at nest_row+7,nest_col+5;fence_udg$;\
      at nest_row+8,nest_col+3;fence_udg$;\
      at nest_row+8,nest_col+5;fence_udg$:\
return

// ==============================================================
// subroutine: last level {{{1

@last_level:

let nest_width=9:\
let nest_height=9:\ // XXX TODO -- Not used.
let nest_row=int(rnd*7)+3:\
let nest_col=int(rnd*20)+2

beep .3,-12

print at top_fence_row,door_col;fence$(1 to 3)

gosub @the_nest

// XXX TODO --
# print at 11,nest_col+5; ink paper_color; paper paper_color;mine_udg$

print \
  at nest_row+int(nest_width/2),nest_col+int(nest_width/2);\
  bill_udg$

return

// ==============================================================
// Sounds {{{1

// XXX TODO --

@sound:
for i=0 to 13:\
  read d: out 65333,i: out 49149,d:\
next i:\
return

@applause_sound:
data 0,0,0,0,0,0,30,64,15,16,15,0,7,24

@no_sound:
data 0,0,0,0,0,0,0,0,0,0,0,0,0,0

// ==============================================================
// Debugging tests {{{1

# rem --------------------------------
# paper 2
# ink 7
# print at 15,15;mine_udg$;" (mine)=";
# gosub @graphics_font
# let tmp= code screen$(15,15)
# gosub @default_font
# print tmp

# print at 16,15;"  (space)=";
# gosub @graphics_font
# let tmp= code screen$(16,15)
# gosub @default_font
# print tmp

# gosub @last_level
# for n=1 to langs
#   let lang=n
#   gosub @rescue
#   pause 0
# next n

# stop

// ==============================================================
// Vimclair BASIC directives {{{1

# #tapmaker zmakebas
#tapmaker bas2tap

#filename DISK
#run 1

// ---------------------------------------------
// Convert UTF-8 characters to UDG codes {{{2

# UDG set 2: Spanish:
#vim %substitute,á,\\A,gIe
#vim %substitute,Á,\\B,gIe
#vim %substitute,é,\\C,gIe
#vim %substitute,É,\\D,gIe
#vim %substitute,í,\\E,gIe
#vim %substitute,Í,\\F,gIe
#vim %substitute,ó,\\G,gIe
#vim %substitute,Ó,\\H,gIe
#vim %substitute,ú,\\I,gI
#vim %substitute,Ú,\\J,gIe
#vim %substitute,ñ,\\K,gIe
#vim %substitute,Ñ,\\L,gIe
#vim %substitute,ü,\\M,gIe
#vim %substitute,Ü,\\N,gIe
#vim %substitute,¿,\\O,gIe
#vim %substitute,¡,\\P,gIe
# %substitute,º,\\Q,gIe
#vim %substitute,«,\\R,gIe
#vim %substitute,»,\\S,gIe

# UDG set 3: Esperanto
#vim %substitute,Ĉ,\\A,gIe
#vim %substitute,ĉ,\\B,gIe
#vim %substitute,Ĝ,\\C,gIe
#vim %substitute,ĝ,\\D,gIe
#vim %substitute,Ĥ,\\E,gIe
#vim %substitute,ĥ,\\F,gIe
#vim %substitute,Ĵ,\\G,gIe
#vim %substitute,ĵ,\\H,gIe
#vim %substitute,Ŝ,\\I,gIe
#vim %substitute,ŝ,\\J,gIe
#vim %substitute,Ŭ,\\K,gIe
#vim %substitute,ŭ,\\L,gIe

// ---------------------------------------------
// Shorten string variable names {{{2

#vim %substitute,\<mine_udg\$,a$,gIe
#vim %substitute,\<blank_row\$,b$,gIe
#vim %substitute,\<bill_udg\$,c$,gIe
#vim %substitute,\<mine_char\$,d$,gIe
#vim %substitute,\<fence\$,f$,gIe
#vim %substitute,\<flower_udg\$,g$,gIe
#vim %substitute,\<record_player\$,h$,gIe
#vim %substitute,\<fence_udg\$,j$,gIe
#vim %substitute,\<text\$,l$,gIe
#vim %substitute,\<replay_controls\$,m$,gIe
#vim %substitute,\<no\$,n$,gIe
#vim %substitute,\<key_udg\$,o$,gIe
#vim %substitute,\<protagonist\$,p$,gIe
#vim %substitute,\<dead_protagonist_udg\$,q$,gIe
#vim %substitute,\<trail\$,t$,gIe
#vim %substitute,\<blank_field_row\$,u$,gIe
#vim %substitute,\<version\$,v$,gIe
#vim %substitute,\<message\$,w$,gIe
#vim %substitute,\<yes\$,y$,gIe

// ---------------------------------------------
// Shorten numeric array names {{{2

#vim %substitute,\<detector_color\>,d,gIe
#vim %substitute,\<flower_col\>,c,gIe
#vim %substitute,\<flower_row\>,r,gIe
#vim %substitute,\<text_len\>,l,gIe

// ---------------------------------------------
// Replace numeric constants {{{2

// Generic
#vim %substitute,\<border_color\>,0,gIe

// Text identifiers
#vim %substitute,\<press_key_text\>,1,gIe
#vim %substitute,\<change_language_txt\>,2,gIe
#vim %substitute,\<credits_txt\>,3,gIe
#vim %substitute,\<enter_initials_txt\>,4,gIe
#vim %substitute,\<instructions_txt\>,5,gIe
#vim %substitute,\<level_txt\>,6,gIe
#vim %substitute,\<near_mines_txt\>,7,gIe
#vim %substitute,\<new_record_txt\>,8,gIe
#vim %substitute,\<open_door_txt\>,9,gIe
#vim %substitute,\<points_txt\>,10,gIe
#vim %substitute,\<putting_mines_txt\>,11,gIe
#vim %substitute,\<record_txt\>,12,gIe
#vim %substitute,\<replay_controls_1_txt\>,13,gIe
#vim %substitute,\<replay_controls_2_txt\>,14,gIe
#vim %substitute,\<safe_zone_txt\>,15,gIe
#vim %substitute,\<start_txt\>,16,gIe
#vim %substitute,\<title_txt\>,17,gIe
#vim %substitute,\<you_need_key_txt\>,18,gIe
#vim %substitute,\<two_thousand_txt\>,19,gIe

// Number of texts
#vim %substitute,\<texts\>,19,gIe

// ---------------------------------------------
// Shorten numeric variable names {{{2

#vim %substitute,\<bottom_fence_row\>,bfr,gIe
#vim %substitute,\<bill_char\>,bh,gIe
#vim %substitute,\<back_surrounding_mines\>,bsm,gIe
#vim %substitute,\<bottom_safe_row\>,bsr,gIe
#vim %substitute,\<door_closed\>,dcl,gIe
#vim %substitute,\<door_col\>,dco,gIe
#vim %substitute,\<enter_time\>,ent,gIe
#vim %substitute,\<exit_time\>,ext,gIe
#vim %substitute,\<fence_char\>,fec,gIe
#vim %substitute,\<flower_char\>,fh,gIe
#vim %substitute,\<first_level\>,fl,gIe
#vim %substitute,\<flowers\>,flo,gIe
#vim %substitute,\<found_char\>,foc,gIe
#vim %substitute,\<front_surrounding_mines\>,fsm,gIe
#vim %substitute,\<ink_color\>,ic,gIe
#vim %substitute,\<key_col\>,kc,gIe
#vim %substitute,\<key_char\>,kch,gIe
#vim %substitute,\<key_row\>,kr,gIe
#vim %substitute,\<last_level\>,ll,gIe
#vim %substitute,\<left_surrounding_mines\>,lsm,gIe
#vim %substitute,\<mine_char\>,mc,gIe
#vim %substitute,\<message_row\>,mr0,gIe
#vim %substitute,\<mine_row\>,mr1,gIe
#vim %substitute,\<mined_rows\>,mr2,gIe
#vim %substitute,\<nest_col\>,nc,gIe
#vim %substitute,\<nest_height\>,nh,gIe
#vim %substitute,\<nest_row\>,nr,gIe
#vim %substitute,\<nest_width\>,nw,gIe
#vim %substitute,\<next_text\>,nt,gIe
#vim %substitute,\<old_col\>,ocol,gIe
#vim %substitute,\<old_row\>,orow,gIe
#vim %substitute,\<paper_color\>,pc,gIe
#vim %substitute,\<protagonist_frame\>,pf,gIe
#vim %substitute,\<paused_replay\>,pr,gIe
#vim %substitute,\<quit_replay\>,qr,gIe
#vim %substitute,\<record\>,r,gIe
#vim %substitute,\<right_surrounding_mines\>,rsm,gIe
#vim %substitute,\<score\>,s,gIe
#vim %substitute,\<start_col\>,sc,gIe
#vim %substitute,\<surrounding_mines\>,sm,gIe
#vim %substitute,\<top_fence_row\>,tfr,gIe
#vim %substitute,\<top_mined_row\>,tmr,gIe
#vim %substitute,\<time_score\>,ts,gIe
#vim %substitute,\<top_safe_row\>,tsr,gIe
#vim %substitute,\<texts\>,tx,gIe
#vim %substitute,\<udg1\>,u1,gIe
#vim %substitute,\<udg2\>,u2,gIe
#vim %substitute,\<udg3\>,u3,gIe
#vim %substitute,\<udg_chars\>,uc,gIe
#vim %substitute,\<udg1_font\>,uf,gIe
#vim %substitute,\<udg1_font_high\>,uh,gIe
#vim %substitute,\<udg1_font_low\>,ul,gIe
#vim %substitute,\<walking_mine_col\>,wmc,gIe
#vim %substitute,\<walking_mine_row\>,wmr,gIe
#vim %substitute,\<walking_mine_step\>,wms,gIe

// ---------------------------------------------
// Shorten function names {{{2

#vim %substitute,\<\(\(def\)\?\s*fn \)\+random_row\>,\1 r,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+random_col\>,\1 c,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+score\$\>,\1 z$,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+seconds\>,\1 s,gIe
#vim %substitute,\<\(\(def\)\?\s*fn \)\+txt\$,\1 t$,gIe

// vim: filetype=vimclairbasic:fileencoding=utf8
